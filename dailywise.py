# -*- coding: utf-8 -*-
"""dailywise.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e657WE_5a2WCE5UK6RMfV-O9yqx9sMNR
"""

4# IMPORT LIBRARIES==
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.model_selection import train_test_split, KFold, GridSearchCV, cross_val_score
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.linear_model import LinearRegression
from lightgbm import LGBMRegressor
from xgboost import XGBRegressor
from catboost import CatBoostRegressor
from statsmodels.tsa.statespace.sarimax import SARIMAX
import warnings
warnings.filterwarnings("ignore")



!pip install catboost

# LOAD & PREPROCESS DATA ===
df = pd.read_csv("/content/POWER_Point_Hourly_20200101_20241231_034d15N_077d58E_LST.csv", skiprows=range(0, 15), header=0, comment='#')
df = df.rename(columns={'2020': 'Year', '1': 'Month', '1.1': 'Day'})
df["DATE"] = pd.to_datetime(df[["Year", "Month", "Day"]])
df.replace(-999, np.nan, inplace=True)
print(df.columns)
# df["Clearness_Index"] = df["Clearness_Index"].replace(0, np.nan)

# AGGREGATE TO DAILY ==
def aggregate_daily(data):
    daily_data = data.groupby("DATE").agg({
        "0.0": lambda x: x.sum() / 1000,  # Assuming '0.0' is Irradiation
        "-25.84": "mean",  # Assuming '-25.84' is Temperature
        "93.01": "mean",  # Assuming '93.01' is RH
        "2.04": "mean",  # Assuming '2.04' is Wind_ Speed
        "0.0.1": "mean",  # Assuming '0.0.1' is Clearness_Index
        "0.0.2": "mean",  # Assuming '0.0.2' is Pressure
        "0": "mean"  # Assuming '0' is Precipitiation
    }).reset_index()
    return daily_data.dropna()

daily_df = aggregate_daily(df)

# SPLIT FEATURES AND TARGET ===
X = daily_df.drop(columns=["DATE", "0.0"])
y = daily_df["0.0"].values.ravel()

x_train, x_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

scaler = StandardScaler()
x_train_scaled = scaler.fit_transform(x_train)
x_test_scaled = scaler.transform(x_test)

# INDIVIDUAL ALGORITHM EVALUATIONS ==

def evaluate_model(name, model, xtr, xts, ytr, yts):
    model.fit(xtr, ytr)
    y_pred_train = model.predict(xtr)
    y_pred_test = model.predict(xts)
    print(f"\n🔹 {name}")
    print(f"Train R²: {r2_score(ytr, y_pred_train):.4f}")
    print(f"Test R² : {r2_score(yts, y_pred_test):.4f}")
    print(f"Test RMSE: {np.sqrt(mean_squared_error(yts, y_pred_test)):.4f}")
    print(f"Test MAE : {mean_absolute_error(yts, y_pred_test):.4f}")
    return model

# 1. Linear Regression
evaluate_model("Linear Regression", LinearRegression(), x_train_scaled, x_test_scaled, y_train, y_test)

# 2. Decision Tree
evaluate_model("Decision Tree", DecisionTreeRegressor(max_depth=5, random_state=42), x_train_scaled, x_test_scaled, y_train, y_test)

# 3. Random Forest
evaluate_model("Random Forest", RandomForestRegressor(n_estimators=100, max_depth=10, random_state=42), x_train_scaled, x_test_scaled, y_train, y_test)

# 4. LightGBM
evaluate_model("LightGBM", LGBMRegressor(), x_train_scaled, x_test_scaled, y_train, y_test)

# 5. XGBoost
evaluate_model("XGBoost", XGBRegressor(n_estimators=100, max_depth=5, random_state=42), x_train_scaled, x_test_scaled, y_train, y_test)

# 6. CatBoost
evaluate_model("CatBoost", CatBoostRegressor(iterations=100, learning_rate=0.1, depth=5, verbose=0), x_train_scaled, x_test_scaled, y_train, y_test)

# ARIMAX TIME SERIES MODEL ==
arimax_df = daily_df.copy()
arimax_df.set_index("DATE", inplace=True)

y_arima = arimax_df["0.0"]
exog_arima = arimax_df.drop(columns=["0.0"])

train_size = int(len(y_arima) * 0.8)
y_train_arima, y_test_arima = y_arima[:train_size], y_arima[train_size:]
exog_train_arima, exog_test_arima = exog_arima[:train_size], exog_arima[train_size:]

model_arima = SARIMAX(y_train_arima, exog=exog_train_arima, order=(2,1,2), seasonal_order=(1,0,1,7),
                      enforce_stationarity=False, enforce_invertibility=False)
fit_arima = model_arima.fit(disp=False)

pred_arima = fit_arima.forecast(steps=len(y_test_arima), exog=exog_test_arima)

# Evaluation
print("\n🔹 ARIMAX (Time Series)")
print(f"R² Score: {r2_score(y_test_arima, pred_arima):.4f}")
print(f"RMSE: {np.sqrt(mean_squared_error(y_test_arima, pred_arima)):.4f}")
print(f"MAE: {mean_absolute_error(y_test_arima, pred_arima):.4f}")

# Plot==
plt.figure(figsize=(14, 5))
plt.plot(y_test_arima.index, y_test_arima, label="Actual")
plt.plot(y_test_arima.index, pred_arima, label="ARIMAX Prediction", color='orange')
plt.title("ARIMAX - Daily Solar Irradiation Forecast")
plt.xlabel("Date")
plt.ylabel("Irradiation (kWh/m²)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# INDIVIDUAL MODEL TRAINING & EVALUATION (OPTIONAL)=====
model_scores = {}
test_predictions = {}

def evaluate_model(name, model):
    model.fit(x_train_scaled, y_train)
    y_pred_test = model.predict(x_test_scaled)
    test_predictions[name] = y_pred_test
    model_scores[name] = r2_score(y_test, y_pred_test)
    print(f"\n🔹 {name}")
    print(f"R² Score: {model_scores[name]:.4f}")
    print(f"RMSE: {np.sqrt(mean_squared_error(y_test, y_pred_test)):.4f}")
    print(f"MAE : {mean_absolute_error(y_test, y_pred_test):.4f}")
    return model

# FUTURE FORECAST (NEXT 7 DAYS) ===
last_exog = exog_arima.iloc[-1:]
future_exog = pd.concat([last_exog] * 7, ignore_index=True)

future_forecast = fit_arima.forecast(steps=7, exog=future_exog)
future_dates = pd.date_range(start=arimax_df.index[-1] + pd.Timedelta(days=1), periods=7)

future_df = pd.DataFrame({
    "Date": future_dates,
    "Forecast_Irradiation": future_forecast.values
})
print("\n📅 Future Forecast (Next 7 Days):")
print(future_df)

# BAR PLOT FOR MODEL COMPARISON ==
plt.figure(figsize=(10, 5))
sns.barplot(x=list(model_scores.keys()), y=list(model_scores.values()), palette='viridis')
plt.ylabel("R² Score")
plt.title("Model Comparison - Daily Solar Irradiation Prediction")
plt.xticks(rotation=30)
plt.grid(True)
plt.tight_layout()
plt.show()

#  Load and Combine Data =================
df = pd.read_csv("/content/POWER_Point_Hourly_20200101_20241231_034d15N_077d58E_LST.csv", skiprows=range(0, 15), header=0, comment='#')
df = df.rename(columns={'2020': 'Year', '1': 'Month', '1.1': 'Day', '0': 'Hour', '0.0': 'Irradiation', '-25.84': 'Temperature', '93.01': 'RH', '2.04': 'Wind_Speed', '0.0.1': 'Clearness_Index', '0.0.2': 'Pressure'})
df["Datetime"] = pd.to_datetime(df[["Year", "Month", "Day", "Hour"]])
df = df[df["Irradiation"] >= 0]
df = df[(df["Hour"] >= 6) & (df["Hour"] <= 17)]  # Keep only 6AM to 5PM
df.replace(-999, np.nan, inplace=True)
df["Clearness_Index"] = df["Clearness_Index"].replace(0, np.nan)
df.dropna(inplace=True)

#  Filter for 6 AM to 5 PM(17) only =================
df = df[df["Hour"].between(6, 17)]

#  Remove invalid values =================
df = df[df["Irradiation"] >= 0]
df.replace(-999, np.nan, inplace=True)

#  Create datetime index =================
df["Datetime"] = pd.to_datetime(df[["Year", "Month", "Day", "Hour"]])
df.set_index("Datetime", inplace=True)
df = df.asfreq("H").fillna(method="ffill")

#Train-test split =================
train_size = int(len(df) * 0.8)
y_train, y_test = target[:train_size], target[train_size:]
exog_train, exog_test = exog[:train_size], exog[train_size:]

#  Fit ARIMAX model =================
from statsmodels.tsa.statespace.sarimax import SARIMAX

model = SARIMAX(y_train,
                exog=exog_train,
                order=(2, 1, 2),
                seasonal_order=(1, 0, 1, 12),
                enforce_stationarity=False,
                enforce_invertibility=False)
model_fit = model.fit(disp=False)

#  Filter only useful daylight hours (6 to 17)
df = df[df['Hour'].between(6, 17)].copy() # Use .copy() to avoid SettingWithCopyWarning

# Remove invalid values
df = df[df["Irradiation"] >= 0].copy() # Use .copy()
df.replace(-999, np.nan, inplace=True)

#  Create datetime and set index, handle duplicates
df["Datetime"] = pd.to_datetime(df[["Year", "Month", "Day", "Hour"]])
df = df.drop_duplicates(subset=['Datetime']).set_index("Datetime") # Drop duplicates before setting index
df = df.asfreq("h").fillna(method="ffill") # Use 'h' for hourly frequency

# Feature selection (only well-correlated)
features = ["Temperature", "RH", "Pressure", "Wind_Speed"]
correlation = df[features + ["Irradiation"]].corr()
print("🔍 Correlation with Irradiation:\n", correlation["Irradiation"])

# Keep only features with good correlation
selected_features = correlation["Irradiation"].abs().sort_values(ascending=False)
selected_features = selected_features[selected_features > 0.2].index.drop("Irradiation").tolist()

#  Target and exogenous
target = df["Irradiation"]
exog = df[selected_features]

#Split into train/test
split = int(0.8 * len(df))
y_train, y_test = target[:split], target[split:]
exog_train, exog_test = exog[:split], exog[split:]

#  Tune ARIMA order (try different values!)
model = SARIMAX(y_train,
                exog=exog_train,
                order=(3, 0, 2),  # Try (3,0,2) or (2,0,2)
                seasonal_order=(1, 0, 1, 12),  # Daily seasonality
                enforce_stationarity=False,
                enforce_invertibility=False)
model_fit = model.fit(disp=False)

# Prediction
y_pred = model_fit.forecast(steps=len(y_test), exog=exog_test)

#  Metrics
r2 = r2_score(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
mae = mean_absolute_error(y_test, y_pred)

print("\n📊 ARIMAX Model Evaluation:")
print(f"R² Score: {r2:.4f}")
print(f"RMSE: {rmse:.4f}")
print(f"MAE: {mae:.4f}")

# Plot
plt.figure(figsize=(14, 5))
plt.plot(y_test.index, y_test, label='Actual')
plt.plot(y_test.index, y_pred, label='Predicted', alpha=0.8)
plt.title("Improved Hourly Irradiation Forecast (6AM–5PM)")
plt.xlabel("Datetime")
plt.ylabel("Irradiation")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

!pip install catboost

import pandas as pd
import numpy as np
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")

# Load data (assuming df is already loaded and preprocessed from previous cells)
# df = pd.read_csv("Data.csv")

# Preprocess (assuming these steps are handled in previous cells based on notebook state)
# df = df[df["Irradiation"] >= 0]
# df.replace(-999, np.nan, inplace=True)
# df["Datetime"] = pd.to_datetime(df[["Year", "Month", "Day", "Hour"]])


# Features for exogenous variables
# Using columns available in the latest df state and relevant for the model
exog_columns = ["Temperature", "RH", "Pressure", "Wind_Speed", "Precipitation"]


# Store metrics and future forecasts
results = []
future_forecasts = [] # Initialize future_forecasts list here

# Loop over each hour from 6 to 17
for hour in range(6, 18):
    print(f"\n⏰ Hour: {hour}:00")

    # Filter data for this hour only
    hourly_df = df[df["Hour"] == hour].copy()

    if len(hourly_df) < 365:
        print("⚠️ Not enough data for modeling. Skipping...")
        continue

    # Create datetime column before handling duplicates and setting index
    hourly_df["Datetime"] = pd.to_datetime(hourly_df[["Year", "Month", "Day", "Hour"]])

    # Handle potential duplicates before setting index and reindexing
    hourly_df = hourly_df.drop_duplicates(subset=['Datetime'])

    hourly_df.set_index("Datetime", inplace=True)
    hourly_df = hourly_df.sort_index().asfreq("D").fillna(method="ffill")


    # Split target and features
    y = hourly_df["Irradiation"]
    # Ensure exog columns exist in the filtered hourly_df
    current_exog_columns = [col for col in exog_columns if col in hourly_df.columns]
    X = hourly_df[current_exog_columns]


    # Train-test split
    split_idx = int(len(hourly_df) * 0.8)
    y_train, y_test = y[:split_idx], y[split_idx:]
    X_train, X_test = X[:split_idx], X[split_idx:]

    # Fit ARIMAX model
    try:
        model = SARIMAX(y_train,
                        exog=X_train,
                        order=(2, 0, 2),
                        seasonal_order=(1, 0, 1, 7),  # weekly pattern
                        enforce_stationarity=False,
                        enforce_invertibility=False)
        model_fit = model.fit(disp=False)

        # Forecast
        y_pred = model_fit.forecast(steps=len(y_test), exog=X_test)

        # Metrics
        r2 = r2_score(y_test, y_pred)
        rmse = np.sqrt(mean_squared_error(y_test, y_pred))
        mae = mean_absolute_error(y_test, y_pred)

        print(f"✅ R² Score: {r2:.4f}, RMSE: {rmse:.2f}, MAE: {mae:.2f}")

        # Store results
        results.append({
            "Hour": hour,
            "R2": r2,
            "RMSE": rmse,
            "MAE": mae
        })

        # Future 7-day forecast (integrate code from cell sWDeVliN3vOb here)
        if not X.empty and not y.empty: # Check if X and y are not empty before fitting future model
            last_exog = X.iloc[-1:]
            # Create future exogenous data by repeating the last available exogenous data for 7 days
            future_exog = pd.concat([last_exog] * 7, ignore_index=True)
            # Set the index of future_exog to match the future dates for forecasting
            future_dates_for_exog = pd.date_range(start=y.index[-1] + pd.Timedelta(days=1), periods=7, freq=hourly_df.index.freq)
            future_exog.index = future_dates_for_exog


            future_model = SARIMAX(y,
                                   exog=X,
                                   order=(2, 0, 2),
                                   seasonal_order=(1, 0, 1, 7),
                                   enforce_stationarity=False,
                                   enforce_invertibility=False)
            future_fit = future_model.fit(disp=False)
            future_pred = future_fit.forecast(steps=7, exog=future_exog)

            # Create DataFrame for future forecast and store
            future_dates = pd.date_range(start=y.index[-1] + pd.Timedelta(days=1), periods=7, freq=hourly_df.index.freq)
            forecast_df = pd.DataFrame({
                "Datetime": future_dates,
                "Forecast_Irradiation": future_pred,
                "Hour": hour
            })
            forecast_df.to_csv(f"arimax_hour_{hour}_future.csv", index=False)
            future_forecasts.append(forecast_df)
        else:
            print(f"⚠️ Skipping future forecast for hour {hour} due to empty data.")


        # Optional plot (integrate code from cell XPsla9-b362e here)
        plt.figure(figsize=(10, 4))
        plt.plot(y_test.index, y_test, label="Actual", alpha=0.8)
        plt.plot(y_test.index, y_pred, label="Predicted", alpha=0.8)
        plt.title(f"Irradiation Forecast at {hour}:00")
        plt.xlabel("Date")
        plt.ylabel("Irradiation")
        plt.legend()
        plt.tight_layout()
        plt.grid(True)
        plt.show()

    except Exception as e:
        print(f"❌ Model failed for hour {hour}. Error: {e}")
        continue

# Final summary table
results_df = pd.DataFrame(results)
print("\n📋 Summary of Hourly ARIMAX Model Performance:")
print(results_df)

# Concatenate all future forecasts
if future_forecasts:
    all_future_forecasts_df = pd.concat(future_forecasts, ignore_index=True)
    print("\n📅 Combined Future Forecast (Next 7 Days for all hours):")
    print(all_future_forecasts_df)
else:
    print("\n📅 No future forecasts were generated.")